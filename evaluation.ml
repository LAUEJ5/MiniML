(* 
                         MiniML -- Evaluation
*)

(* This module implements a small untyped ML-like language under
   various operational semantics.
 *)

open Expr ;;
  
(* Exception for evaluator runtime, generated by a runtime error in
   the interpreter *)
exception EvalError of string ;;
  
(* Exception for evaluator runtime, generated by an explicit `raise`
   construct in the object language *)
exception EvalException ;;


module type ENV = sig
    (* the type of environments *)
    type env
	   
    (* the type of values (including closures) stored in
       environments *)
    type value =
      | Val of expr
      | Closure of (expr * env)
   
    (* empty () -- Returns an empty environment *)
    val empty : unit -> env

    (* close expr env -- Returns a closure for `expr` and its `env` *)
    val close : expr -> env -> value

    (* lookup env varid -- Returns the value in the `env` for the
       `varid`, raising an `Eval_error` if not found *)
    val lookup : env -> varid -> value

    (* extend env varid loc -- Returns a new environment just like
       `env` except that it maps the variable `varid` to the `value`
       stored at `loc`. This allows later changing the value, an
       ability used in the evaluation of `letrec`. To make good on
       this, extending an environment needs to preserve the previous
       bindings in a physical, not just structural, way. *)
    val extend : env -> varid -> value ref -> env

    (* env_to_string env -- Returns a printable string representation
       of environment `env` *)
    val env_to_string : env -> string
                                 
    (* value_to_string ?printenvp value -- Returns a printable string
       representation of a value; the optional flag `printenvp`
       (default: `true`) determines whether to include the environment
       in the string representation when called on a closure *)
    val value_to_string : ?printenvp:bool -> value -> string
  end

module Env : ENV =
  struct
    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    let empty () : env = []

    let close (exp : expr) (env : env) : value =
      Closure (exp, env)

    let lookup (env : env) (varname : varid) : value =
      match List.find_opt (fun (str, _) -> str = varname) env with
      | None -> raise (EvalError ("Variable " 
                                            ^ varname ^ " could not be found."))
      | Some (_, var) -> !var

    let extend (env : env) (varname : varid) (loc : value ref) : env =
      (varname, loc) :: (List.remove_assoc varname env)
    
    let env_to_string (env : env) : string =
      let envstr = ref "" in
        List.iter 
        (fun (name, v) -> envstr := !envstr ^ "NAME: " ^ name ^ " VALUE: " ^
         (match !v with
         | Val expr
         | Closure (expr, _) -> exp_to_concrete_string expr)                           
         ^ "\n") env;
        !envstr

    let value_to_string ?(printenvp : bool = true) (v : value) : string =
      match v with
      | Val (ex) -> exp_to_concrete_string ex
      | Closure (ex, env) -> 
        if printenvp then exp_to_concrete_string ex ^ " with " 
                                                          ^ (env_to_string env)
        else exp_to_concrete_string ex

  end
;;


(*......................................................................
  Evaluation functions

  Each of the evaluation functions below evaluates an expression `exp`
  in an environment `env` returning a result of type `value`. We've
  provided an initial implementation for a trivial evaluator, which
  just converts the expression unchanged to a `value` and returns it,
  along with "stub code" for three more evaluators: a substitution
  model evaluator and dynamic and lexical environment model versions.

  Each evaluator is of type `expr -> Env.env -> Env.value` for
  consistency, though some of the evaluators don't need an
  environment, and some will only return values that are "bare
  values" (that is, not closures).  *)

(* The TRIVIAL EVALUATOR, which leaves the expression to be evaluated
   essentially unchanged, just converted to a value for consistency
   with the signature of the evaluators. *)
   
let eval_t (exp : expr) (_env : Env.env) : Env.value =
  (* coerce the expr, unchanged, into a value *)
  Env.Val exp ;;

open Env ;;

let unop_eval (unop: Expr.unop) (exp: Env.value) : expr =
  match unop, exp with
  | Negate, Val (Num (x)) -> Num (~-x)
  | Negate, Val (Bool (truth)) -> Bool(not truth)
  | Negate, Val (Float (x)) -> Float (~-.x)
  | _ , _ -> raise (EvalError "Unop doesn't eval") ;;

let binop_eval (op: Expr.binop) (expVal1 : Env.value) (expVal2: Env.value) : expr =
  match op, expVal1, expVal2 with
  | Plus, Val (Num (x)), Val (Num (y)) -> Num (x + y)
  | Fl_plus, Val (Float (x)), Val (Float (y)) -> Float (x +. y)
  | Minus, Val (Num (x)), Val (Num (y)) -> Num (x - y)
  | Fl_minus, Val (Float (x)), Val (Float (y)) -> Float (x -. y)
  | Times, Val (Num (x)), Val (Num (y)) -> Num (x * y)
  | Fl_times, Val (Float (x)), Val (Float (y)) -> Float (x *. y)
  | Divides, Val (Num (x)), Val (Num (y)) -> Num (x / y)
  | Fl_divides, Val (Float (x)), Val (Float (y)) -> Float (x /. y)
  | LessThan, Val (Num (x)), Val (Num (y)) -> Bool (x < y)
  | LessThan, Val (Float (x)), Val (Float (y)) -> Bool (x < y)
  | GreaterThan, Val (Num (x)), Val (Num (y)) -> Bool (x < y)
  | GreaterThan, Val (Float (x)), Val (Float (y)) -> Bool (x < y)
  | Equals, Val (Num (x)), Val (Num (y)) -> Bool (x = y)
  | Equals, Val (Float (x)), Val (Float (y)) -> Bool (x = y)
  | Equals, Val (Bool (truth1)), Val (Bool (truth2)) -> Bool (truth1 = truth2)
  | Concat, Val (String (st1)), Val (String (st2)) -> String (st1 ^ st2)
  | _, _, _ -> raise (EvalError "Binop doesn't eval") ;;
  
(* The SUBSTITUTION MODEL evaluator *)
   
let eval_s (_exp : expr) (_env : Env.env) : Env.value =
  let rec subevs (ex : expr) : expr =
    match ex with
    | Var var -> raise (EvalError ("Unbound value " ^ var))
    | Unop (un, ex1) -> unop_eval un (Val (subevs (subevs ex1))) 
    | Binop (bi, ex1, ex2) -> binop_eval bi (Val (subevs (subevs ex1))) 
                                                    (Val (subevs (subevs ex2)))
    | Conditional (ex1, ex2, ex3) -> 
      (match subevs ex1 with
      | Bool truth -> (if truth then subevs ex2
                       else subevs ex3)
      | _ -> raise (EvalError "Condition isn't a bool"))
    | Let (var, def, body) -> subevs (subst var (subevs def) body)
    | Letrec (var, def, body) -> 
      subevs (subst var (subevs (subst var 
                    (Letrec(var, (subevs def), Var var)) (subevs def))) body)
    | App (func, argu) -> 
      (match subevs func with
      | Fun (var, func) -> subevs (subst var (subevs argu) func)
      | _ -> raise (EvalError "Unable to apply function"))
    | Raise
    | Unassigned -> raise (EvalError "Unable to evaluate Raise/Unassigned")
    | Ref _ 
    | Deref _ -> raise (EvalError "Unable to evaluate refs with substitution")
    | expr -> expr
    in
    Val (subevs _exp) ;;
     
(* The DYNAMICALLY-SCOPED ENVIRONMENT MODEL evaluator *)
   
let rec eval_d (_exp : expr) (_env : Env.env) : Env.value =
  match _exp with
  | Var var -> Env.lookup _env var
  | Conditional (ex1, ex2, ex3) ->
    (match eval_d ex1 _env with
    | Val (Bool truth) -> if truth then eval_d ex2 _env else eval_d ex3 _env
    | _ -> raise (EvalError "Condition isn't a bool"))
  | Unop (unop, ex1) -> Val (unop_eval unop (eval_d ex1 _env))
  | Binop (bi, ex1, ex2) -> 
                        Val (binop_eval bi (eval_d ex1 _env) (eval_d ex2 _env))
  | Let (var, def, body) -> eval_d (App (Fun (var, body), def)) _env
  | Letrec (var, def, body) -> 
    let reffer = ref (eval_d def _env) in
    eval_d body (Env.extend _env var reffer)
  | App (func, argu) ->
    (match eval_d func _env with
    | Val (Fun (var, ex)) -> eval_d ex 
                                  (Env.extend _env var (ref (eval_d argu _env)))
    | _ -> raise (EvalError "Cannot apply this function"))
  | Raise
  | Unassigned -> raise (EvalError "Unable to evaluate Raise/Unassigned")
  | Ref _
  | Deref _ -> raise (EvalError "Use special evaluator to handle references")
  | expr -> Val expr ;;

(* The LEXICALLY-SCOPED ENVIRONMENT MODEL evaluator *)
   

let rec eval_l (_exp : expr) (_env : Env.env) : Env.value =
  match _exp with
  | App (func, argu) ->
    (match eval_d func _env with
    | Closure (Fun (var, def), env') -> 
      (eval_l def (Env.extend env' var (ref (eval_l argu _env))))
    | _ -> raise (EvalError "Unable to apply as a function"))
  | Fun (var, def) -> Env.close (Fun (var, def)) _env
  | Let (id, e1, e2) ->
      eval_l e2 (Env.extend _env id (ref ((eval_l e1 _env))))
  | Letrec (var, ex1, ex2) ->
      let temp = ref (Env.Val Unassigned) in
      let env' = Env.extend _env var temp in
      temp := eval_l ex1 env';
      eval_l ex2 env'
  | _ -> eval_d _exp _env ;;



(* The EXTENDED evaluator *)

let rec eval_e (_exp : expr) (_env : Env.env) : Env.value * Env.env =
  match _exp with
  | Ref (r, ex) -> let ex', env' = eval_e ex _env in
      Val (Unit ()), Env.extend env' r (ref ex')
  | Deref ex -> Env.lookup _env ex, _env
  | _ -> eval_l _exp _env, _env ;;
  
(* IMPORTANT!!! Change the evaluate variabel below to change the 
method of evaluation. *)
   
let evaluate = eval_s ;;
